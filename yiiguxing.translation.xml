<application>
  <component name="AppStorage">
    <histories>
      <item value="finish" />
      <item value="file Directory Path" />
      <item value="directory Path" />
      <item value="rename Same File Name" />
      <item value="Solution" />
      <item value="exist" />
      <item value="Relation" />
      <item value="complet" />
      <item value="read Success Cd Id List" />
      <item value="features" />
      <item value="logout Sub System" />
      <item value="清除token失败" />
      <item value="Invalidating" />
      <item value="splice" />
      <item value="拼接" />
      <item value="contain" />
      <item value="contains" />
      <item value="character" />
      <item value="Character" />
      <item value="Could not get any response There was an error connecting to https://localhost:8080/api/supervise/getSupervise. Why this might have happened: The server couldn't send a response: Ensure that the backend is working properly Self-signed SSL certificates are being blocked: Fix this by turning off 'SSL certificate verification' in Settings &gt; General Proxy configured incorrectly Ensure that proxy is configured correctly in Settings &gt; Proxy Request timeout: Change request timeout in Settings &gt; General" />
      <item value="Catalog" />
      <item value="Type safe sql support, plugin can recognize mybatis dynamic sql Generate mybatis crud code by Intellij database table or add a database connection Generate mybatis sql based on mybatis interface method name like spring data jpa, with this, you don't have to write most sql for non join query support generate statement with if test Database generate crud could generate multiple times when you add or delete columns, plugin will auto merge code Full mybatis sql auto complete, recognize mybatis tag in xml, like where trim set include ect,provide sql completion after those tag Jump from mybatis dao interface to mapper xml each other Refactor for mybatis interface method name,refid,resultMap ect Auto complete for mybatis param,if test,foreach,resultMap,refid in sql Generate create table sql from java class Mybatis Param refactor and inspection Ognl support, if test when test ${ bind foreach collection, refactor and inspection and auto completion Jump from refid resultMap to their definition, refactor their name as well Generate page query by mapper interface method Spring support for mybatis, inject mybatis mapper to spring bean,support SpringBoot Refid,resultMap,keyProperty,property auto complete  Add @param for mapper method Resultmap column complete and inspection by parse your select statement Auto map resultMap column and property Generate mybatis mapper testcase from mybatis interface method by database connection, make you test mapper method quicker Full inspection for mybatis, like unused sql in xml, mapper method not have sql in xml, check if resultMap property is right ect  https://github.com/gejun123456/MyBatisCodeHelper-Pro to learn more." />
      <item value="mar" />
      <item value="/** * &lt;p&gt; * A {@link org.springframework.session.SessionRepository} that is implemented using * Spring Data's {@link org.springframework.data.redis.core.RedisOperations}. In a web * environment, this is typically used in combination with {@link SessionRepositoryFilter} * . This implementation supports {@link SessionDeletedEvent} and * {@link SessionExpiredEvent} by implementing {@link MessageListener}. * &lt;/p&gt; * * &lt;h2&gt;Creating a new instance&lt;/h2&gt; * * A typical example of how to create a new instance can be seen below: * * &lt;pre&gt; * JedisConnectionFactory factory = new JedisConnectionFactory(); * * RedisOperationsSessionRepository redisSessionRepository = new RedisOperationsSessionRepository(factory); * &lt;/pre&gt; * * &lt;p&gt; * For additional information on how to create a RedisTemplate, refer to the * &lt;a href = &quot;http://docs.spring.io/spring-data/data-redis/docs/current/reference/html/&quot; &gt; * Spring Data Redis Reference&lt;/a&gt;. * &lt;/p&gt; * * &lt;h2&gt;Storage Details&lt;/h2&gt; * * The sections below outline how Redis is updated for each operation. An example of * creating a new session can be found below. The subsequent sections describe the * details. * * &lt;pre&gt; * HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe creationTime 1404360000000 maxInactiveInterval 1800 lastAccessedTime 1404360000000 sessionAttr:attrName someAttrValue sessionAttr2:attrName someAttrValue2 * EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 * APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe &quot;&quot; * EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 * SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe * EXPIRE spring:session:expirations1439245080000 2100 * &lt;/pre&gt; * * &lt;h3&gt;Saving a Session&lt;/h3&gt; * * &lt;p&gt; * Each session is stored in Redis as a * &lt;a href=&quot;http://redis.io/topics/data-types#hashes&quot;&gt;Hash&lt;/a&gt;. Each session is set and * updated using the &lt;a href=&quot;http://redis.io/commands/hmset&quot;&gt;HMSET command&lt;/a&gt;. An * example of how each session is stored can be seen below. * &lt;/p&gt; * * &lt;pre&gt; * HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe creationTime 1404360000000 maxInactiveInterval 1800 lastAccessedTime 1404360000000 sessionAttr:attrName someAttrValue sessionAttr:attrName2 someAttrValue2 * &lt;/pre&gt; * * &lt;p&gt; * In this example, the session following statements are true about the session: * &lt;/p&gt; * &lt;ul&gt; * &lt;li&gt;The session id is 33fdd1b6-b496-4b33-9f7d-df96679d32fe&lt;/li&gt; * &lt;li&gt;The session was created at 1404360000000 in milliseconds since midnight of 1/1/1970 * GMT.&lt;/li&gt; * &lt;li&gt;The session expires in 1800 seconds (30 minutes).&lt;/li&gt; * &lt;li&gt;The session was last accessed at 1404360000000 in milliseconds since midnight of * 1/1/1970 GMT.&lt;/li&gt; * &lt;li&gt;The session has two attributes. The first is &quot;attrName&quot; with the value of * &quot;someAttrValue&quot;. The second session attribute is named &quot;attrName2&quot; with the value of * &quot;someAttrValue2&quot;.&lt;/li&gt; * &lt;/ul&gt; * * * &lt;h3&gt;Optimized Writes&lt;/h3&gt; * * &lt;p&gt; * The {@link RedisSession} keeps track of the properties that have changed and only * updates those. This means if an attribute is written once and read many times we only * need to write that attribute once. For example, assume the session attribute * &quot;sessionAttr2&quot; from earlier was updated. The following would be executed upon saving: * &lt;/p&gt; * * &lt;pre&gt; * HMSET spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe sessionAttr:attrName2 newValue * &lt;/pre&gt; * * &lt;h3&gt;SessionCreatedEvent&lt;/h3&gt; * * &lt;p&gt; * When a session is created an event is sent to Redis with the channel of * &quot;spring:session:channel:created:33fdd1b6-b496-4b33-9f7d-df96679d32fe&quot; such that * &quot;33fdd1b6-b496-4b33-9f7d-df96679d32fe&quot; is the sesion id. The body of the event will be * the session that was created. * &lt;/p&gt; * * &lt;p&gt; * If registered as a {@link MessageListener}, then * {@link RedisOperationsSessionRepository} will then translate the Redis message into a * {@link SessionCreatedEvent}. * &lt;/p&gt; * * &lt;h3&gt;Expiration&lt;/h3&gt; * * &lt;p&gt; * An expiration is associated to each session using the * &lt;a href=&quot;http://redis.io/commands/expire&quot;&gt;EXPIRE command&lt;/a&gt; based upon the * {@link org.springframework.session.data.redis.RedisOperationsSessionRepository.RedisSession#getMaxInactiveIntervalInSeconds()} * . For example: * &lt;/p&gt; * * &lt;pre&gt; * EXPIRE spring:session:sessions:33fdd1b6-b496-4b33-9f7d-df96679d32fe 2100 * &lt;/pre&gt; * * &lt;p&gt; * You will note that the expiration that is set is 5 minutes after the session actually * expires. This is necessary so that the value of the session can be accessed when the * session expires. An expiration is set on the session itself five minutes after it * actually expires to ensure it is cleaned up, but only after we perform any necessary * processing. * &lt;/p&gt; * * &lt;p&gt; * &lt;b&gt;NOTE:&lt;/b&gt; The {@link #getSession(String)} method ensures that no expired sessions * will be returned. This means there is no need to check the expiration before using a * session * &lt;/p&gt; * * &lt;p&gt; * Spring Session relies on the expired and delete * &lt;a href=&quot;http://redis.io/topics/notifications&quot;&gt;keyspace notifications&lt;/a&gt; from Redis to * fire a SessionDestroyedEvent. It is the SessionDestroyedEvent that ensures resources * associated with the Session are cleaned up. For example, when using Spring Session's * WebSocket support the Redis expired or delete event is what triggers any WebSocket * connections associated with the session to be closed. * &lt;/p&gt; * * &lt;p&gt; * Expiration is not tracked directly on the session key itself since this would mean the * session data would no longer be available. Instead a special session expires key is * used. In our example the expires key is: * &lt;/p&gt; * * &lt;pre&gt; * APPEND spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe &quot;&quot; * EXPIRE spring:session:sessions:expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe 1800 * &lt;/pre&gt; * * &lt;p&gt; * When a session expires key is deleted or expires, the keyspace notification triggers a * lookup of the actual session and a {@link SessionDestroyedEvent} is fired. * &lt;/p&gt; * * &lt;p&gt; * One problem with relying on Redis expiration exclusively is that Redis makes no * guarantee of when the expired event will be fired if they key has not been accessed. * Specifically the background task that Redis uses to clean up expired keys is a low * priority task and may not trigger the key expiration. For additional details see * &lt;a href=&quot;http://redis.io/topics/notifications&quot;&gt;Timing of expired events&lt;/a&gt; section in * the Redis documentation. * &lt;/p&gt; * * &lt;p&gt; * To circumvent the fact that expired events are not guaranteed to happen we can ensure * that each key is accessed when it is expected to expire. This means that if the TTL is * expired on the key, Redis will remove the key and fire the expired event when we try to * access they key. * &lt;/p&gt; * * &lt;p&gt; * For this reason, each session expiration is also tracked to the nearest minute. This * allows a background task to access the potentially expired sessions to ensure that * Redis expired events are fired in a more deterministic fashion. For example: * &lt;/p&gt; * * &lt;pre&gt; * SADD spring:session:expirations:1439245080000 expires:33fdd1b6-b496-4b33-9f7d-df96679d32fe * EXPIRE spring:session:expirations1439245080000 2100 * &lt;/pre&gt; * * &lt;p&gt; * The background task will then use these mappings to explicitly request each session * expires key. By accessing the key, rather than deleting it, we ensure that Redis * deletes the key for us only if the TTL is expired. * &lt;/p&gt; * &lt;p&gt; * &lt;b&gt;NOTE&lt;/b&gt;: We do not explicitly delete the keys since in some instances there may be * a race condition that incorrectly identifies a key as expired when it is not. Short of * using distributed locks (which would kill our performance) there is no way to ensure * the consistency of the expiration mapping. By simply accessing the key, we ensure that * the key is only removed if the TTL on that key is expired. * &lt;/p&gt; * * @author Rob Winch * @since 1.0 */" />
      <item value="Transmitting" />
      <item value="Country" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="25" />
        <entry key="ENGLISH" value="26" />
        <entry key="ROMANIAN" value="1" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="keepFormat" value="true" />
    <option name="targetLanguageSelection" value="PRIMARY_LANGUAGE" />
  </component>
</application>